askai(){ type ai>/dev/null 2>&1||ai(){ askai "$@";};local CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/askai" PATH_FILE="$CONF_DIR/.path" D="${TMPDIR:-/tmp}/g_ai" API="https://generativelanguage.googleapis.com/v1beta/models";if [ -s "$PATH_FILE" ];then read -r SAVED_D<"$PATH_FILE";if [ -d "$SAVED_D" ]&&[ -w "$SAVED_D" ];then D="$SAVED_D";else echo -e "\033[1;33mWarning: Persistent path '$SAVED_D' inaccessible. Falling back to $D\033[0m">&2;fi;fi;mkdir -p "$D" 2>/dev/null&&chmod 700 "$D"||{ echo "Error: Failed to secure $D">&2;return 1;};if ! command -v jq>/dev/null||! command -v curl>/dev/null;then echo -e "\033[1;31mError: Missing curl/jq.\033[0m">&2;return 1;fi;local PF RO ERR_TMP="" pipe_smart=0 MACRO_Q=();PF=$(mktemp "$D/payload.XXXXXX.json")||return 1;RO=$(mktemp "$D/r.XXXXXX.tmp")||{ rm -f "$PF";return 1;};trap 'rm -f "$PF" "$RO" "${ERR_TMP}" "$D"/slice.*.json 2>/dev/null;unset -f require_interaction handle_err _rollback_last _display_history _chat_submenu _ui_read _jq_in _slice_hist 2>/dev/null' RETURN;_jq_in(){ local f="${!#}" t;t=$(mktemp "$D/j.XXXXXX")||return 1;if jq "${@:1:$#-1}" "$f">"$t" 2>/dev/null&&[ -s "$t" ];then cat "$t">"$f"&&rm -f "$t";else rm -f "$t";return 1;fi;};_slice_hist(){ local s="$1" d="$2" hn="$3" tn="$4" ht="$5" tt="$6";if [ -n "$hn" ];then jq ".[0:${hn}]" "$s">"$d";elif [ -n "$tn" ];then [ "$tn" -eq 0 ]&&echo "[]">"$d"||jq ".[-${tn}:]" "$s">"$d";elif [ -n "$ht" ];then jq --argjson ht "$ht" '. as $m|reduce range(length) as $i({r:[],t:0};($m[$i].parts[0].text//""|length/4|floor)as $k|if .t+$k<=$ht then{r:(.r+[$m[$i]]),t:(.t+$k)}else . end)|.r' "$s">"$d";elif [ -n "$tt" ];then jq --argjson tt "$tt" '. as $m|(length-1)as $l|reduce range($l;-1;-1)as $i({r:[],t:0};($m[$i].parts[0].text//""|length/4|floor)as $k|if .t+$k<=$tt then{r:[$m[$i]]+.r,t:(.t+$k)}else . end)|.r' "$s">"$d";else cp "$s" "$d";fi;};_ui_read(){ local is_sec=0;[ "$1" == "-s" ]&&{ is_sec=1;shift;};local __v=$1 __p=$2 val="";if [ ${#MACRO_Q[@]} -gt 0 ];then val="${MACRO_Q[0]}";MACRO_Q=("${MACRO_Q[@]:1}");[ "$is_sec" -eq 1 ]&&echo -e "${__p}\033[1;35m***\033[0m (macro)">&2||echo -e "${__p}\033[1;35m${val}\033[0m (macro)">&2;printf -v "$__v" "%s" "$val";return 0;fi;if [ "$pipe_smart" -eq 1 ]&&[ ! -t 0 ];then if [ "$__p" == "Prompt > " ];then val=$(cat);if [ -n "$val" ];then echo -e "${__p}\033[1;35m(stream read)\033[0m">&2;printf -v "$__v" "%s" "$val";return 0;fi;elif IFS= read -r val;then [ "$is_sec" -eq 1 ]&&echo -e "${__p}\033[1;35m***\033[0m (smart)">&2||echo -e "${__p}\033[1;35m${val}\033[0m (smart)">&2;printf -v "$__v" "%s" "$val";return 0;fi;fi;if [ "$interactive" -eq 0 ];then echo -e "\n\033[1;31mError: Interaction required.\033[0m">&2;return 1;fi;if [ "$is_sec" -eq 1 ];then read -s -p "$__p" val</dev/tty;echo >&2;else read -p "$__p" val</dev/tty;fi;printf -v "$__v" "%s" "$val";};require_interaction(){ [ "$interactive" -eq 0 ]&&{ echo -e "\033[1;31mError: $1 requires interaction (-pipe hard).\033[0m">&2;return 1;};};_rollback_last(){ _jq_in 'del(.[-1])' "$HF";};handle_err(){ echo -e "\n\033[1;31mâŒ API Error:\033[0m $1">&2;_rollback_last;if [[ "$1" == *"limit: 0"* ]];then echo -e "\033[1;33mâš ï¸  Quota Exceeded (Limit 0). Blocking '$M'.\033[0m">&2;local kh;kh=$(cksum<<<"$k"|cut -d' ' -f1);_jq_in --arg k "$kh" --arg m "$M" '.[$k]+=[$m]|.[$k]|=unique' "$BF";fi;};_display_history(){ local hf="$1" skip_tok="${2:-0}" label="$3" hn="$4" tn="$5" ht="$6" tt="$7";if [ ! -s "$hf" ]||[ "$(cat "$hf")" = "[]" ];then echo -e "\033[1;33m(No history for '$label')\033[0m";return 0;fi;local sliced_tmp;sliced_tmp=$(mktemp "$D/slice.XXXXXX.json")||return 1;_slice_hist "$hf" "$sliced_tmp" "$hn" "$tn" "$ht" "$tt";local total shown shown_tok;total=$(jq 'length' "$hf");shown=$(jq 'length' "$sliced_tmp");shown_tok=$(jq '[.[].parts[0].text//""|length]|add//0|./4|floor' "$sliced_tmp");echo -e "\033[1;34mâ”€â”€â”€ History: $label â”€â”€â”€\033[0m";if [ -n "$hn" ]||[ -n "$tn" ]||[ -n "$ht" ]||[ -n "$tt" ];then echo -e "\033[2mShowing $shown of $total messages | ~$shown_tok tokens\033[0m";else echo -e "\033[2m$shown messages | ~$shown_tok tokens\033[0m";fi;echo "";jq -r --argjson skip "$skip_tok" 'to_entries[]|(.key+1)as $i|.value.role as $r|(.value.parts[0].text//"")as $t|($t|length/4|floor)as $k|(if $r=="user" then "\u001b[1;36m[\($i)] You (~\($k) tokens):\u001b[0m" else "\u001b[1;32m[\($i)] Gemini (~\($k) tokens):\u001b[0m" end),(if $skip>0 and $k>$skip then "  \u001b[2m[skipped â€” ~\($k) toks (exceeds skip limit)]\u001b[0m" else $t end), ""' "$sliced_tmp" 2>/dev/null;};_chat_submenu(){ local tgt="$1" c_head="" c_tail="" c_ht="" c_tt="" c_skip="0" b_id="" c_sel="" src_hf="$D/h_${tgt}.json";[ -f "$src_hf" ]&&jq -e . "$src_hf">/dev/null 2>&1||echo "[]">"$src_hf";while true;do echo -e "\n\033[1;34m--- Chat Menu: $tgt ---\033[0m\n1) \033[1;32mSet as Default & Use\033[0m\n2) \033[1;36mUse Temporarily\033[0m\n3) \033[1;33mView History\033[0m (Applies filters)\n4) \033[1;35mBranch to New ID\033[0m (Forks using filters)\n----------------------------------------\n5) Msg Head limit:     \033[1;36m[${c_head:-(All)}]\033[0m\n6) Msg Tail limit:     \033[1;36m[${c_tail:-(All)}]\033[0m\n7) Token Head limit:   \033[1;36m[${c_ht:-(All)}]\033[0m\n8) Token Tail limit:   \033[1;36m[${c_tt:-(All)}]\033[0m\n9) Skip-Over (Tokens): \033[1;36m[${c_skip:-0}]\033[0m\nr) Return to Chat List\n0) Abort">&2;_ui_read c_sel "Select > "||return 0;case "$c_sel" in 1) return 10;;2) return 11;;3) _display_history "$src_hf" "$c_skip" "$tgt" "$c_head" "$c_tail" "$c_ht" "$c_tt";_ui_read c_sel "(Press Enter to continue...) ";;4) _ui_read b_id "Enter New Branch ID: ";b_id=$(sed 's/[^a-zA-Z0-9_-]//g'<<<"$b_id");[ -z "$b_id" ]&&continue;local dst_hf="$D/h_${b_id}.json" dst_sf="$D/s_${b_id}.txt" src_sf="$D/s_${tgt}.txt";if [ -f "$dst_hf" ];then _ui_read c_sel "'$b_id' exists. Overwrite? (y/N): ";[[ ! "$c_sel" =~ ^[Yy] ]]&&continue;fi;local sl_tmp;sl_tmp=$(mktemp "$D/slice.XXXXXX.json");_slice_hist "$src_hf" "$sl_tmp" "$c_head" "$c_tail" "$c_ht" "$c_tt";mv "$sl_tmp" "$dst_hf";[ -s "$src_sf" ]&&cp "$src_sf" "$dst_sf"||touch "$dst_sf";echo -e "\033[1;32mâœ… Branched to '$b_id'.\033[0m">&2;chat_id="$b_id";return 2;;5) _ui_read c_head "Msg Head (empty for All): ";c_head=$(grep -o '^[0-9]*'<<<"$c_head");c_tail="";c_ht="";c_tt="";;6) _ui_read c_tail "Msg Tail (empty for All): ";c_tail=$(grep -o '^[0-9]*'<<<"$c_tail");c_head="";c_ht="";c_tt="";;7) _ui_read c_ht "Token Head (empty for All): ";c_ht=$(grep -o '^[0-9]*'<<<"$c_ht");c_head="";c_tail="";c_tt="";;8) _ui_read c_tt "Token Tail (empty for All): ";c_tt=$(grep -o '^[0-9]*'<<<"$c_tt");c_head="";c_tail="";c_ht="";;9) _ui_read c_skip "Skip-Over Tokens (0 disable): ";c_skip=$(grep -o '^[0-9]*'<<<"$c_skip");;[rR]) return 12;;0) return 0;;esac;done;};local BF="$D/b.json" STF="$D/stream.txt" IDF="$D/id.txt" KF="$D/k.txt" AF="$D/a.txt" MF="$D/m.txt" CF="$D/c.txt" WF="$D/w.json";for f in "$BF" "$WF";do jq -e . "$f">/dev/null 2>&1||echo "{}">"$f";done;[[ "$(<"$STF" 2>/dev/null)" != "1" ]]&&echo "0">"$STF";[[ "$(<"$CF" 2>/dev/null)" != "1" ]]&&echo "0">"$CF";local chat_id="default";local ci=$(sed 's/[^a-zA-Z0-9_-]//g' "$IDF" 2>/dev/null);[ -n "$ci" ]&&chat_id="$ci"||echo "default">"$IDF";local M="gemini-flash-latest";[ -s "$MF" ]&&M=$(<"$MF");local k="" n=0 s="" mo=0 show_all=0 stream_mode=0 select_id=0 del_mode=0 manage_key=0 arg_id="" arg_m="" arg_k="" p="";local interactive=1 has_pipe=0 continuous=0;[ ! -t 0 ]&&has_pipe=1;[ "$(<"$CF" 2>/dev/null)" == "1" ]&&continuous=1;if [ "$#" -eq 0 ]&&[ "$has_pipe" -eq 0 ];then echo -e "\033[1;33mUsage:\033[0m askai [flags] <prompt>\n\033[1;36mContext:\033[0m ID=[$chat_id] | Model=[$M]\n\033[1;37mSession Flags:\033[0m\n  -id [chat_name]    Select Chat, View History, or Branch (Menu)\n  -n                 New Chat Menu (Clear/Rename)\n  -d                 Delete History Menu\n\033[1;37mConfig Flags:\033[0m\n  -m [model_name]    Select/Edit Model (empty to list)\n  -k [api_key]       Set/Manage API Key\n  -s [sys_prompt]    Set System Prompt\n  -c, --continuous   Toggle/Set Continuous Mode\n  --stream           Toggle/Set Streaming Output\n  --persistence      Move/Edit Data Storage Location\n\033[1;37mAdvanced / Automation:\033[0m\n  -pipe smart        Automate UI via stdin lines, remainder is prompt\n  -pipe hard         Disable interactive menus entirely\n  -id|name|val|val   Pipe automation via arguments (Macro string)">&2;return 0;fi;while [[ "$#" -gt 0 ]];do case "$1" in -h|--help) askai;return 0;;--persistence) require_interaction "Persistence Menu"||return 1;echo -e "\033[1;34m--- Persistence ---\033[0m\nCurrent: $D">&2;local np;_ui_read np "New path: "||return 1;[ -z "$np" ]&&return 0;np="${np/#\~/$HOME}";if mkdir -p "$CONF_DIR" "$np" 2>/dev/null&&chmod 700 "$np" 2>/dev/null&&touch "$np/.test" 2>/dev/null;then rm -f "$np/.test";cp -r "$D/"* "$np/" 2>/dev/null;echo "$np">"$PATH_FILE";D="$np";echo -e "\033[1;32mMigrated to $D\033[0m">&2;return 0;else echo -e "\033[1;31mError: Path '$np' invalid/unwritable.\033[0m">&2;return 1;fi;;-c|--continuous) if [[ "$#" -eq 1 && -z "$p" ]];then require_interaction "Continuous Menu"||return 1;echo -e "\033[1;34m--- Continuous Settings ---\033[0m\n1) Enable Always\n2) Enable Once\n3) Disable Default\n0) Abort">&2;local c;_ui_read c "Choice > "||return 1;case "$c" in 1) echo "1">"$CF";return 0;;2) continuous=1;return 0;;3) echo "0">"$CF";return 0;;*) return 0;;esac;else continuous=1;shift;fi;;--stream) if [[ "$#" -eq 1 && -z "$p" ]];then require_interaction "Stream Menu"||return 1;echo -e "\033[1;34m--- Stream Settings ---\033[0m\n1) Enable Always\n2) Enable Once\n0) Abort">&2;local c;_ui_read c "Choice > "||return 1;[ "$c" = "1" ]&&echo "1">"$STF";[ "$c" = "2" ]&&stream_mode=1;return 0;else stream_mode=1;shift;fi;;-pipe) if [[ "$2" == "hard" ]];then interactive=0;shift 2;elif [[ "$2" == "smart" ]];then pipe_smart=1;interactive=1;shift 2;else return 1;fi;;-k|--key) if [[ -n "$2" && ! "$2" =~ ^- ]];then arg_k="$2";shift 2;else manage_key=1;shift;fi;;-id|--id) if [[ -n "$2" && ! "$2" =~ ^- ]];then if [[ "$2" == *"|"* ]];then arg_id="${2%%|*}";set -f;IFS='|' read -r -a new_macros<<<"${2#*|}";set +f;MACRO_Q+=("${new_macros[@]}");else arg_id="$2";fi;shift 2;else select_id=1;shift;fi;;-id\|*|--id\|*) local fv="${1#*|}";arg_id="${fv%%|*}";local m="${fv#*|}";if [[ "$m" != "$fv" ]];then set -f;IFS='|' read -r -a new_macros<<<"$m";set +f;MACRO_Q+=("${new_macros[@]}");fi;shift;;-n) n=1;shift;;-d|--delete) del_mode=1;shift;;-s) if [[ -n "$2" ]];then s="$2";shift 2;else return 1;fi;;-m) mo=1;if [[ -n "$2" && ! "$2" =~ ^- ]];then arg_m="$2";shift 2;else shift;fi;;-1) show_all=1;shift;;*) p="${p:+$p }$1";shift;;esac;done;local is_ui=0;[[ -z "$p" && "$has_pipe" -eq 0 && "$pipe_smart" -eq 0 && ${#MACRO_Q[@]} -eq 0 ]]&&is_ui=1;if [ "$manage_key" -eq 1 ];then require_interaction "Key Manager"||return 1;local ck="None" ca="Off";[ -s "$KF" ]&&ck="...$(<"$KF"|tail -c 5)";[ "$(<"$AF" 2>/dev/null)" = "1" ]&&ca="On";echo -e "\033[1;33m--- Key Manager ---\033[0m\nStored: $ck | Auto-Use: $ca\n1) Update Key\n2) Toggle Auto\n3) Temp Key\n0) Abort">&2;local kc;_ui_read kc "Choice > "||return 1;case "$kc" in 1) local nk;_ui_read -s nk "New Key: "||return 1;echo "$nk">"$KF";echo 1>"$AF";return 0;;2) [ "$ca" == "On" ]&&echo 0>"$AF"||echo 1>"$AF";return 0;;3) _ui_read -s arg_k "Temp Key: "||return 1;;*) return 0;;esac;fi;if [ "$del_mode" -eq 1 ];then require_interaction "Delete Menu"||return 1;echo -e "\033[1;31m--- Delete Menu ---\033[0m\n1) Delete ALL histories\n2) Delete Current [$chat_id]\n0) Abort">&2;local dc;_ui_read dc "Choice > "||return 1;case "$dc" in 1) rm -f "$D"/h_*.json;return 0;;2) rm -f "$D/h_${chat_id}.json";chat_id="default";echo "default">"$IDF";return 0;;*) return 0;;esac;fi;if [ "$n" -eq 1 ];then require_interaction "New Chat Menu"||return 1;while true;do local nid;_ui_read nid "New Session ID: "||return 1;local clean_nid=$(sed 's/[^a-zA-Z0-9_-]//g'<<<"$nid");[ -z "$clean_nid" ]&&continue;if [ -f "$D/h_${clean_nid}.json" ];then echo -e "\033[1;33mExists.\033[0m\n1) Overwrite\n2) New Name\n3) Rename Old\n0) Abort">&2;local nc;_ui_read nc "> "||return 1;case "$nc" in 1) chat_id="$clean_nid";rm -f "$D/h_${chat_id}.json";echo "$chat_id">"$IDF";break;;2) continue;;3) local old;_ui_read old "Rename to: "||return 1;mv "$D/h_${clean_nid}.json" "$D/h_${old}.json";chat_id="$clean_nid";echo "$chat_id">"$IDF";break;;*) return 0;;esac;else chat_id="$clean_nid";echo "$chat_id">"$IDF";break;fi;done;fi;if [ -n "$arg_id" ];then if [ "$is_ui" -eq 1 ];then require_interaction "ID Selector"||return 1;_chat_submenu "$arg_id";local ret=$?;[ $ret -eq 10 ]&&{ chat_id="$arg_id";echo "$chat_id">"$IDF";};[ $ret -eq 11 ]&&chat_id="$arg_id";[ $ret -eq 12 ]||[ $ret -eq 0 ]&&return 0;else chat_id="$arg_id";fi;fi;if [ "$select_id" -eq 1 ];then require_interaction "Session List"||return 1;while true;do echo -e "\n\033[1;34m--- Select Chat ---\033[0m">&2;local fl=();while IFS= read -r f;do [ -n "$f" ]&&fl+=("$f");done< <(ls -t "$D"/h_*.json 2>/dev/null);local ids=() i=1;if [ ${#fl[@]} -gt 0 ];then for f in "${fl[@]}";do local nm=$(basename "$f"|sed 's/^h_//;s/\.json$//');ids+=("$nm");read -r msg_n chars_n<<<"$(jq -r '(length|tostring)+" "+([.[].parts[].text//""]|join("")|length|tostring)' "$f" 2>/dev/null||echo "0 0")";local cur="";[ "$nm" == "$chat_id" ]&&cur="\033[1;32m(*)\033[0m";printf "%2d) \033[1;36m%-18s\033[0m %8d chars | %6d toks | %4d msgs %b\n" "$i" "$nm" "$chars_n" "$((chars_n/4))" "$msg_n" "$cur">&2;((i++));done;else echo "(No histories)">&2;fi;echo -e "\n+) Create New\n0) Abort">&2;local sel;_ui_read sel "Select > "||return 1;if [[ "$sel" == "0" ]];then return 0;elif [[ "$sel" == "+" ]];then local nn;_ui_read nn "New Name: "||return 1;local pk=$(sed 's/[^a-zA-Z0-9_-]//g'<<<"$nn");[ -z "$pk" ]&&continue;_chat_submenu "$pk";local ret=$?;[ $ret -eq 10 ]&&{ chat_id="$pk";echo "$chat_id">"$IDF";break;};[ $ret -eq 11 ]&&{ chat_id="$pk";break;};[ $ret -eq 2 ]&&break;[ $ret -eq 0 ]&&return 0;elif [[ "$sel" =~ ^[0-9]+$ && "$sel" -le "${#ids[@]}" && "$sel" -gt 0 ]];then local pk="${ids[$((sel-1))]}";_chat_submenu "$pk";local ret=$?;[ $ret -eq 10 ]&&{ chat_id="$pk";echo "$chat_id">"$IDF";break;};[ $ret -eq 11 ]&&{ chat_id="$pk";break;};[ $ret -eq 2 ]&&break;[ $ret -eq 0 ]&&return 0;fi;done;fi;local HF="$D/h_${chat_id}.json" SF="$D/s_${chat_id}.txt";jq -e . "$HF">/dev/null 2>&1||echo "[]">"$HF";[ ! -f "$SF" ]&&touch "$SF";if [ -n "$arg_k" ];then if [ "$is_ui" -eq 1 ];then require_interaction "Key Confirm"||return 1;echo -e "\033[1;33mAPI Key: '...${arg_k: -4}'\033[0m\n1) Save Default\n2) Use Temp\n0) Abort">&2;local c;_ui_read c "Choice > "||return 1;case "$c" in 1) k="$arg_k";echo "$k">"$KF";echo 1>"$AF";;2) k="$arg_k";;*) return 0;;esac;else k="$arg_k";fi;fi;if [ -z "$k" ];then if [ -s "$KF" ]&&[ "$(<"$AF" 2>/dev/null)" = "1" ];then k=$(<"$KF");else require_interaction "Setup"||return 1;_ui_read -s k "Enter API Key: "||return 1;echo "$k">"$KF";echo 1>"$AF";fi;fi;if [ -n "$arg_m" ];then if [ "$is_ui" -eq 1 ];then require_interaction "Model Confirm"||return 1;echo -e "\033[1;33mModel: '$arg_m'\033[0m\n1) Save Default\n2) Use Temp\n0) Abort">&2;local c;_ui_read c "Choice > "||return 1;case "$c" in 1) M="$arg_m";echo "$M">"$MF";;2) M="$arg_m";;*) return 0;;esac;else M="$arg_m";fi;fi;if [ "$mo" -eq 1 ]&&[ -z "$arg_m" ];then require_interaction "Model List"||return 1;while true;do echo -e "\033[1;30mFetching models...\033[0m">&2;local jm;jm=$(curl -s --connect-timeout 10 -H "x-goog-api-key: $k" "$API");local err=$(jq -r '.error.message//empty' 2>/dev/null<<<"$jm");if [ -n "$err" ];then echo -e "\033[1;31mâŒ API Error:\033[0m $err">&2;return 1;fi;local bk=$(<"$BF") kh=$(cksum<<<"$k"|cut -d' ' -f1) jq_s='.models[]|select(.supportedGenerationMethods[]?|contains("generateContent"))|.name|=sub("^models/";"")|.score=0|if(.name|contains("-pro"))then .score+=1000 elif(.name|contains("-flash"))then .score+=800 elif(.name|contains("-lite"))then .score+=600 else . end|if(.name|test("gemini-[0-9]\\.[0-9]"))then .score+=((.name|capture("gemini-(?<v>[0-9]\\.[0-9])").v|tonumber)*100)else . end|if(.name|contains("-latest"))then .score+=10000 elif(.name|contains("-exp"))then .score+=-5000 elif(.name|contains("-preview"))then if(.name|test("preview-[0-9]{2}-[0-9]{2}"))then .score+=-2000 else .score+=500 end else .score+=5000 end|if(.name|test("gemma|learnlm|tts|image|robotics|computer-use|thinking"))then .score+=-50000 else . end|select($a=="1" or(.name as $n|($bk[$h]//[])|index($n)|not))|{name:.name,score:.score}';local ml=();mapfile -t ml< <(jq -r --arg h "$kh" --arg a "$show_all" --argjson bk "$bk" "$jq_s"<<<"$jm"|jq -rs 'sort_by(.score)|reverse|.[].name');local hc=$(jq -r --arg h "$kh" '.[$h]//[]|length'<<<"$bk") i=1;for md in "${ml[@]}";do if [ "$md" == "$M" ];then echo -e "$i) \033[1;32m$md (*)\033[0m">&2;else echo "$i) $md">&2;fi;((i++));done;echo "-1) list 0 limit models too ($hc hidden)">&2;local sl;_ui_read sl "Select (1-${#ml[@]}, 0 Abort): "||return 1;if [ "$sl" == "-1" ];then show_all=$((1-show_all));continue;fi;[ "$sl" = "0" ]&&return 0;if [[ "$sl" =~ ^[0-9]+$ && "$sl" -le "${#ml[@]}" ]];then local sel="${ml[$((sl-1))]}";echo -e "\033[1;33m$sel\033[0m\n1) Save Default\n2) Use Temp\n3) Cancel\n4) Retry">&2;local sc;_ui_read sc "Choice > "||return 1;case "$sc" in 1) M="$sel";echo "$M">"$MF";break;;2) M="$sel";break;;3) break;;4) continue;;*) return 0;;esac;fi;done;fi;[ -n "$s" ]&&echo "$s">"$SF";if [ "$has_pipe" -eq 1 ]&&[ -z "$p" ]&&[ "$pipe_smart" -eq 0 ]&&[ ${#MACRO_Q[@]} -eq 0 ];then p=$(</dev/stdin);fi;while true;do if [ -z "$p" ];then if [ ${#MACRO_Q[@]} -gt 0 ];then _ui_read p "Prompt > "||return 1;elif [ "$continuous" -eq 1 ]||{ [ "$pipe_smart" -eq 1 ]&&[ ! -t 0 ];};then echo -e "\033[1;34m> (Stream read... Ctrl+D to send)\033[0m">&2;p=$(cat);else _ui_read p "Prompt > "||return 1;fi;[ -z "$p" ]&&return 0;fi;read -r msg_n h_chars<<<"$(jq -r '(length+1|tostring)+" "+([.[].parts[].text//""]|join("")|length|tostring)' "$HF" 2>/dev/null||echo "1 0")";if [ "$(((${h_chars:-0}+${#p})/4))" -gt 200000 ]&&! jq -e --arg id "$chat_id" '.[$id]' "$WF">/dev/null 2>&1;then echo -e "\033[1;33mâš ï¸ Session '$chat_id' exceeded ~200k tokens. Trim via askai -id > Branch\033[0m">&2;_jq_in --arg id "$chat_id" '.[$id]=true' "$WF";fi;local sys="";[ -s "$SF" ]&&sys=" sys:loaded";echo -e "\033[1;30mid:$chat_id msg:$msg_n ts:$(date -u +"%Y%m%d_%H%M%Sutc") toks:$((${h_chars:-0}/4))+$(( ${#p}/4 )) md:$M$sys\033[0m">&2;_jq_in --arg t "$p" '.+[{"role":"user","parts":[{"text":$t}]}]' "$HF"||{ echo "Resetting corrupt history...">&2;echo "[]">"$HF";_jq_in --arg t "$p" '.+[{"role":"user","parts":[{"text":$t}]}]' "$HF"||return 1;};jq -n --slurpfile h "$HF" --arg s "$(<"$SF")" '{contents:$h[0]}+(if($s|length>0)then{system_instruction:{parts:[{text:$s}]}}else{}end)'>"$PF";local ft="" us="0" c_args=(-s --connect-timeout 10 -H "x-goog-api-key: $k" -H "Content-Type: application/json" -d "@$PF");[[ "$(<"$STF" 2>/dev/null)" == "1" ]]&&us="1";[ "$stream_mode" -eq 1 ]&&us=1;echo -e "\033[1;32mðŸ¤– Gemini ($chat_id):\033[0m">&2;if [ "$us" == "1" ];then >"$RO";ERR_TMP=$(mktemp "$D/err.XXXXXX.tmp");curl "${c_args[@]}" -N --max-time 120 -X POST "$API/$M:streamGenerateContent?alt=sse"|jq --unbuffered -R -j 'if startswith("data: ")then .[6:]|fromjson?|if .error.message then "\(.error.message)\n"|halt_error(1) else .candidates[0].content.parts[0].text//empty end elif startswith("{")then fromjson?|.error.message|select(.!=null)|"\(.)\n"|halt_error(1) else empty end' 2>"$ERR_TMP"|tee "$RO";echo "">&2;if [ -s "$ERR_TMP" ];then handle_err "$(<"$ERR_TMP")";rm -f "$ERR_TMP";ERR_TMP="";return 1;fi;rm -f "$ERR_TMP";ERR_TMP="";ft=$(<"$RO");if [ -z "$ft" ];then echo -e "\033[1;31mâŒ Network Error / Timeout.\033[0m">&2;_rollback_last;return 1;fi;else local r;r=$(curl "${c_args[@]}" --max-time 30 -X POST "$API/$M:generateContent");if [ -z "$r" ];then echo -e "\033[1;31mâŒ Network Error / Timeout.\033[0m">&2;_rollback_last;return 1;fi;local er;er=$(jq -r '.error.message//empty'<<<"$r");if [ -n "$er" ];then handle_err "$er";return 1;fi;ft=$(jq -r '.candidates[0].content.parts[0].text//empty'<<<"$r");printf "%s\n" "$ft";if [ -z "$ft" ];then echo -e "\033[1;33mâš ï¸ Empty response (safety filter/quota).\033[0m">&2;_rollback_last;return 1;fi;fi;[ -n "$ft" ]&&_jq_in --arg t "$ft" '.+[{"role":"model","parts":[{"text":$t}]}]' "$HF";if [ "$continuous" -eq 0 ]&&[ ${#MACRO_Q[@]} -eq 0 ];then break;fi;p="";done;}
[[ "${BASH_SOURCE[0]}" == "${0}" ]]&&askai "$@"
